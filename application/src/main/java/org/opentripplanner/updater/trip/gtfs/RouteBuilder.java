package org.opentripplanner.updater.trip.gtfs;

import java.util.Objects;
import java.util.Optional;
import org.opentripplanner.core.model.i18n.I18NString;
import org.opentripplanner.core.model.i18n.NonLocalizedString;
import org.opentripplanner.core.model.id.FeedScopedId;
import org.opentripplanner.gtfs.mapping.TransitModeMapper;
import org.opentripplanner.transit.model.basic.TransitMode;
import org.opentripplanner.transit.model.network.Route;
import org.opentripplanner.transit.model.organization.Agency;
import org.opentripplanner.transit.service.TransitService;
import org.opentripplanner.updater.trip.gtfs.model.AddedRoute;
import org.opentripplanner.updater.trip.gtfs.model.TripDescriptor;

class RouteBuilder {

  record Result(boolean newRouteCreated, Route route) {}

  private final TransitService transitService;

  public RouteBuilder(TransitService transitService) {
    this.transitService = transitService;
  }

  Result build(FeedScopedId tripId, TripDescriptor tripDescriptor) {
    var optionalRoute = getRoute(tripId.getFeedId(), tripDescriptor);
    var route = optionalRoute.orElseGet(() -> createRoute(tripDescriptor, tripId));
    return new Result(optionalRoute.isEmpty(), route);
  }

  private Route createRoute(TripDescriptor tripDescriptor, FeedScopedId tripId) {
    // the route in this update doesn't already exist, but the update contains the information so it will be created
    var routeId = tripDescriptor.routeId().map(id -> new FeedScopedId(tripId.getFeedId(), id));
    return routeId
      .map(id -> {
        var builder = Route.of(id);

        var addedRouteExtension = AddedRoute.ofTripDescriptor(tripDescriptor);

        var agency = transitService
          .findAgency(new FeedScopedId(tripId.getFeedId(), addedRouteExtension.agencyId()))
          .orElseGet(() -> fallbackAgency(tripId.getFeedId()));

        builder.withAgency(agency);

        builder.withGtfsType(addedRouteExtension.routeType());
        var mode = TransitModeMapper.mapMode(addedRouteExtension.routeType());
        builder.withMode(mode);

        // Create route name
        var name = Objects.requireNonNullElse(
          addedRouteExtension.routeLongName(),
          tripId.toString()
        );
        builder.withLongName(new NonLocalizedString(name));
        builder.withUrl(addedRouteExtension.routeUrl());
        return builder.build();
      })
      .orElseGet(() -> {
        var builder = Route.of(tripId);

        builder.withAgency(fallbackAgency(tripId.getFeedId()));
        // Guess the route type as it doesn't exist yet in the specifications
        // Bus. Used for short- and long-distance bus routes.
        builder.withGtfsType(3);
        builder.withMode(TransitMode.BUS);
        // Create route name
        I18NString longName = NonLocalizedString.ofNullable(tripId.getId());
        builder.withLongName(longName);
        return builder.build();
      });
  }

  /**
   * Create dummy agency for added trips.
   */
  private Agency fallbackAgency(String feedId) {
    return Agency.of(new FeedScopedId(feedId, "autogenerated-gtfs-rt-added-route"))
      .withName("Agency automatically added by GTFS-RT update")
      .withTimezone(transitService.getTimeZone().toString())
      .build();
  }

  private Optional<Route> getRoute(String feedId, TripDescriptor tripDescriptor) {
    return tripDescriptor
      .routeId()
      .flatMap(id -> Optional.ofNullable(transitService.getRoute(new FeedScopedId(feedId, id))));
  }
}
